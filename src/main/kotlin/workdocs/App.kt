/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package workdocs
import com.amazonaws.services.workdocs.*
import com.amazonaws.services.workdocs.model.*
import com.beust.jcommander.JCommander
import com.beust.jcommander.Parameter
import com.beust.jcommander.ParameterException
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import mu.KotlinLogging.logger
import java.io.*
import workdocs.*
import workdocs.WorkDocs.findWorkDoc
import workdocs.WorkDocs.getFolder
import workdocs.WorkDocs.listAll

abstract class CommonArgs
{
  @Parameter(names =["--folder-id"],description = "Folder ID")
  var folderID: String = "359145ea251b5c82f99311daa400da6d959b0ba13d73602c9c2df48ee16062dd"

  @Parameter(names=["--organization","--organization-id"],description = "organization id")
  var orginazation = "d-926722377d"

  @Parameter(names=["--user"], description="User ID")
  var user: String = "S-1-5-21-3846250425-2220392149-3191951183-1109&d-926722377d"

  @Parameter(names=["--profile"])
  lateinit var profile: String


  @Parameter(names=["--region"])
  lateinit var region: String


  @Parameter(names=["--input", "--source"],
      description="Import from file/url")
  var source: List<File> = mutableListOf()

  @Parameter(names=["--output", "--dest"],
      description="Output file/url")
  public var output: String? = null

  abstract fun run() : Unit


}

fun pushDir( client: AmazonWorkDocsClient , curdir: String , dir: File ) {
    val res = client.createFolder(CreateFolderRequest().withParentFolderId(curdir).withName(dir.name))
    res.metadata
}

class CommandImport : CommonArgs()
{

  override fun run() {
  /*
    val client = getClient()
    val cb = ContentManagerBuilder.standard().withWorkDocsClient(client).build()
    var curFolder = folder
    for( f in source ) {
      f.walk().onEnter {
        println("Enter:${it}")
    //       curFolder = pushdDir( client,  curFolder , it )

        true
      }.onFail {f, e->
        println("Error: ${f}: ${e}")
      }.forEach {
        println("Each: ${it}")

      }
    }

    /*

      f.inputStream().use {ins->
        val upload = cb.uploadDocumentStream(UploadDocumentStreamRequest().withDocumentName(f.name)
          .withContentCreatedTimestamp(f.ctime)
          .withDocumentSizeInBytes(f.length())
          .withContentModifiedTimestamp(f.modtime)
          .withParentFolderId(folder)
          .withContentType( contentTypeFor(f,true))
          .withStream(ins))
        println(upload.pretty())
      }
    }

     */
   */
  }
}
fun pl(any:Any) = println(any.pretty())
class CommandList : CommonArgs() {
  @Parameter(description = "Files to list")
  var files : MutableList<String> = mutableListOf()

  @Parameter(names =["-r","--recurse"],description = "recursive")
  var recurse : Boolean = false

  @Parameter(names = ["-l", "--long"], description = "List files/folders")
  var long : Boolean = false

  @Parameter(names = ["-v", "--versions"], description = "List versions")
  var versions : Boolean = false
  var indent : Int = 0

  override fun run() {
    if (files.isEmpty())
      listFolder(folderID)

    for (f in files)
      listFile(WorkDocs.WorkDocName(f, folderID))

  }
  fun print(file: WorkDocs.WorkDoc) {

    if( long ) pl(file) else println("""${file.id} ${if(file.isFile) "F" else "D" } ${" ".repeat(indent)}${file.name}""")
  }

  fun listFile(name : WorkDocs.WorkDocName) {
    val f = findWorkDoc(name)
    print(f)
    if( f.isFolder ) listFolder(f.id)
  }
  fun listFolder(id: String ) {
    val folder = getFolder(id)
      listAll(id).forEach {
        print(it)
        if( it.isFolder && recurse ) {
          indent++
          listFolder(it.id)
          indent--
        }
      }
  }
}
class CommandShared : CommonArgs()
{

  @Parameter(names=["-l","--long"],description = "List long")
  var long: Boolean = false

  override fun run() {
    val df = WorkDocs.client.getResources(GetResourcesRequest().withUserId(user).withCollectionType("SHARED_WITH_ME"))
    df.folders.forEach{
      if( long )
        pl( it )
      else
        pl( it.name)
    }
    df.documents.forEach {
      if( long)
        pl(it)
      else
        pl(it.latestVersionMetadata.name)
    }



  }
}
class CommandUsers : CommonArgs()
{

  override fun run() {
    WorkDocs.client.describeUsers(DescribeUsersRequest().withOrganizationId(orginazation)).users.forEach {
      pl( it )
    }


  }
}
val objectMapper = jacksonObjectMapper().writerWithDefaultPrettyPrinter()
fun Any.pretty() = objectMapper.writeValueAsString(this)
class CommandInfo : CommonArgs()
{

  override fun run() {
    val u = WorkDocs.client.getCurrentUser(GetCurrentUserRequest())
    println( u.user.pretty() )

  }
}


class CommandMain
{
  @Parameter(names=arrayOf("--help"), description="Help")
  var help: Boolean=false
}
val log = logger{}
fun main(args: Array<String>) {
  log.info{"main"}
  val commands=mapOf<String, CommonArgs>(
      "info" to CommandInfo(),
      "ls" to CommandList(),
      "import" to CommandImport(),
      "list" to CommandList(),
      "users" to CommandUsers(),
      "shared" to CommandShared()
  )

  var jb= JCommander.newBuilder().addObject( CommandMain())
  commands.forEach { (name, command) -> jb.addCommand(name, command) }
  var jc=jb.build()


  try
  {
    jc.parse(*args)
      if( jc.parsedCommand.isNullOrEmpty() )
        jc.usage()
      else
        commands[jc.getParsedCommand()]!!.run()
  }
  catch (e: ParameterException)
  {
    System.err.println(e.message)
    e.usage()
  }
  catch (e: Throwable)
  {
    log.error(e){e.message}
    e.printStackTrace(System.err)
  }

}


